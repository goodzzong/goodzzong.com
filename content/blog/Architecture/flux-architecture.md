---
title: Flux 아키텍쳐란 무엇인가
date: 2019-11-13 15:11:04
category: Architecture
---

## 배경

`Flux` 는  Facebook이 가지고 있던 특정 문제점들을 해결하기 위해 개발되었다.
문제점들 중 가장 잘 알려져 있는 것은 알림(notification) 버그다.
Facebook 에 로그인 하면 메시지 아이콘에 알림이 표시 되어 있지만 그 아이콘을 클릭
해서 들어가보면 아무런 메시지가 없었다. 알림은 사라지지만, 다시 알림이 나타나고
다시 들어가면 또 다시 메시지는 나타나지 않았다.
이 문제를 해결했지만 업데이트를 하다보면 곧 다시 나타났다. 이 사이클은 계속 반복 되었다.

그래서 Facebook은 단순하게 문제를 해결하기 보다, 좀 더 근본적으로 시스템을 예측
가능하게 만들어서 문제를 해결하길 원했다.

Facebook이 찾은 근본적인 문제점은 데이터가 애플리케이션을 흐르는 방법에 있었다.
기존에는 모델(model)이 렌더링을 하기위해 뷰(view) 레이어로 데이터를 보냈을 것이다.
사용자와의 상호작용이 뷰를 통해 일어나기 때문에 사용자의 액션에 따라 뷰가 모델을
업데이트 해야할 필요가 있었다. 그로 인해 의존성이 생기고 모델이 다른 모델을 
업데이트 해야할 때도 있었다.

Facebook 같은 복잡한 구조의 애플리케이션은 다수의 모델이 존재하고 다수의 뷰가 있기 때문에
서로 관계 되는 엄청나게 복잡한 구조로 연결이 되어있다. 그렇기 때문에 데이터의 흐름을 보장하기 힘들고
예측할 수 없는 결과로 이끌게 된다.

그래서 Facebook은 다른 종류의 아키텍처를 시도하기로 결정했다. 이 구조에서 데이터는
단방향으로만 흐르고, 새로운 데이터를 넣으면 처음부터 흐름이 다시 시작된다.
이 아키텍처를 Flux라고 불렀다.

## Flux 아키텍처란

`Flux`는 클라이언트-사이드 웹어플리케이션을 만들기 위해 사용하는 어플리케이션 아키텍처이다.
단방향 데이터 흐름을 활용하여 뷰 컴포넌트를 구성하는 React를 보완하는 역할을 한다.
`Flux`는 다음의 핵심적인 3가지 구성요소가 있다.
1. 디스패처(dispatcher)
2. 스토어(Store)
3. 뷰(React 컴포넌트)

위의 배경에서도 설명 했듯이 데이터를 올바르게 다루기 위해 시작 되었다.
간단하게 흐름을 보자면 다음과 같다.

`Flux`는 사용자가 상호작용을 할 때, `뷰`는 중앙의 `디스패처`를 통해 `액션`을 
전달하게 된다. 어플리케이션의 데이터와 비지니스 로직을 가지고 있는  `스토어`는 
`액션`이 전달되면 이 `액션`을 바탕으로 상태를 변경하고 변경 이벤트를 내보낸다.
변경 된것을 `컨트롤러 뷰`에서 확인하고 자신의 아래에 있는 모든 `뷰`에게 새로운 
상태를 넘겨준다.

## 구조와 데이터 흐름

![Flux 어플리케이션 단방향 데이터 흐름](../../assets/code_example.png)

### 액션(Action) 및 액션 생성자(Action creator)

애플리케이션의 상태를 변경하거나 `뷰`를 업데이트 하고 싶다면 `액션`을 생성해야 한다.
`액션 생성자`는 이러한 `액션`을 생성한다. `액션`은 `Type`과 `payload`가 포함되었고 그것으로
구분한다. `액션`은 대부분 뷰에서의 사용자 상호작용에서 발생한다.


### 디스패처(Dispatcher)

모든 데이터는 중앙 허브인 `디스패처`를 통해 흐른다. `디스패처`는 `스토어`의 콜백을 등록하고
콜백을 실행한 이후에 `액션`을 모든 `스토어`로 전달한다. 등록된 콜백을 활용해 `스토어`는 
관리하고 있는 상태 중 어떤 `액션`이라도 관련이 있다면 전달해준다.
`액션 생성 함수`가 `액션`이 있다고 `디스패처`에게 알려주면 모든 `스토어`는 해당 `액션`을 앞서
등록한 콜백으로 전달한다. 규모가 커지는 애플리케이션이면 `디스패처`의 역할은 더욱 필수적이다.
`스토어` 간에 의존성을 특정적인 순서로 콜백을 실행하는 과정으로 관리하기 때문이다.
`스토어`는 다른 `스토어`의 업데이트가 끝날때까지 선언적으로 기다릴 수 있고 끝나는 순서에
따라 스스로 갱신한다.




### 스토어(Store)

`스토어`는 애플리케이션의 상태와 로직을 포함한다.
`스토어`의 역할은 전통적인 MVC의 모델과 비슷하지만 많은 객체의 상태를 관리 할 수 있다.
단순히 ORM 스타일의 객체 컬랙션을 관리하는 것을 넘어 어플리케이션 내의 개별적인
도메인 에서 상태를 관리한다.
자신을 `디스패처`에 등록하고 콜백을 제공한다. 이 콜백은 `액션`을 파라미터로 받고 
`스토어`의 등록된 콜백의 내부에서 switch문을 사용한 `액션 타입`을 활용하여 `액션`을 
해석하고 `스토어` 내부 메서드에 적절하게 연결될 수 있는 훅을 제공한다.
결과적으로 `액션`은 `디스패처`를 통해 `스토어`의 상태를 갱신한다.

### 컨트롤러 뷰(the controller view)와 뷰(the view)

React는 조화롭고 자유로운 형태로 다시 랜더링 할 수 있는 `뷰`를 `뷰 레이어`로 제공한다.
`스토어`에 의해 이벤트를 중계할 수 있는 특별한 종류의 `뷰`가 있다.
이 뷰를 `컨트롤러 뷰` 라고 부른다. `컨트롤러 뷰`는 `스토어`에서 상태겨 변경 된 것을 
알려주면 `컨트롤러 뷰`는 자신의 아래에 있는 모든 뷰에게 새로운 상태를 넘겨준다.

`컨트롤러 뷰`는 위계의 최상위에서 마치 컨트롤러와 같은 역할을 지속적으로 수행해 
하위에 있는 뷰가 가능한 순수하게, 함수적으로 유지될 수 있도록 한다.


## Resources

- <https://bestalign.github.io/2015/10/06/cartoon-guide-to-flux/>
- <https://haruair.github.io/flux/docs/overview.html>