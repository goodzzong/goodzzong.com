---
title: 코딩을 지탱하는 기술
date: 2022-06-04 11:06:41
category: books
---

# 1장 효율적으로 언어 배우기

## 1.1 비교를 통한 배움

### 규칙은 언어마다 다르다.

지금은 이렇게 약속하는 게 보다 수월하다고 생각하니 그렇게 합시다 라고 정해놓은 규칙일뿐

절대적인건 아니다.

### C언어와 Ruby의 참거짓 값

C언어는 0이 거짓이고 이외의 값은 참이다.

Ruby에서는 0이 참이다.

### Java의 참거짓 값

참거짓 값을 위한 형을 가지고 있어서 조건식에서도 그 형을 사용하지 않으면 안 된다.

0은 단순히 정수형을 의미하기 때문에 조건식에 0을 사용하면 컴파일 에러가 발생한다.

0이 참인 언어, 0이 거짓인 언어, 0이 참도 거짓도 아닌 언어가 존재하고 있는 것이다.

## 1.2 역사를 통한 배움

### 언어 설계자의 의도를 이해하자.

어떤 흐름으로 언어가 작성 됐는지 알아야 해당 기능이 왜 필요한지 이해 할 수 있다.

### 어떤 언어를 배워야 하는지는 아무도 모른다.

어떤 언어를 배우면 좋을까요? 라는 질문은 무의미하다.

시대에 따라 어떻게 될지는 모르는 것이다.

### 언어에 의존하지 않는 보편적인 지식의 습득

다양한 언어를 비교해보며 공부하고 언어의 역사나 이유를 조사함으로, 언어가 바뀌어도 통용할 수 있는

이해력을 기를 필요가 있다.

# 2장 프로그래밍 언어를 조감하다

프로그래밍 언어는 인간을 편하게 하기 위해 만들어졌다.

- ENIAC
  - 1946년에 발명
  - 무엇을 계산할지 목적에 따라 프로그램을 변경할 수 있었다.
  - 17,468 개의 진공관을 사용한 거대한 컴퓨터
  - 수많은 단자에 케이블을 연결하는 것이 프로그래밍이었다.
- EDSAC
  - 1949년에 개발
  - 테이프 구멍을 뚫어서 데이터를 표현
- FORTRAN
  - x \* y + z 라고 표현하는 것이 지금은 당연하지만 그것을 최초로 표현한 언어.
  - 수식을 기계어로 변환하는 것 FORTRAN 의 틀징

## 2.2 프로그래밍 언어 탄생의 목적

### 나태 - 프로그래머의 삼대 미덕

전체 에너지 소비를 줄이기 위해 대부분의 능력을 집중하는 기질.

요점은 편하게 하다 이다.

Perl 이라는 이름은 Practical extraction and report language( 실용적 데이터 취득 및 리포트 작성 언어)

Perl는 리포트 작성을 수월하게 하기 위해 만들어진 언어이다.

### 언어에 따라 다른 '편리함' 의 의미

**무엇을 편하게 하고 싶은 것인가?**

C++ 는 빠른 실행 속도를 중시. 결과적으로 언어 사양이 더 복잡

Scheme 은 언어 사양을 쉽게 파악할 수 있는 데 중점을 뒀다.

**어떤 프로그램을 편하게 만들고 싶은가?**

Python은 다른 사람이 쓴 코드를 쉽게 해석할 수 있는 데 중점을 두고 있다.

Scheme 보다 C 에 가깝고 많은 제어 구문을 채용한다.

인텐드를 강조한다.

속도가 느리며, 사양도 복잡하다.

PHP는 웹서비스를 쉽게 만든다. 문장 처리는 편하게 하지는 못한다.

Haskell, OCaml 등의 ML(Meta-language) 처리 계통 언어는 문장처리를 쉽게 만든다.

그러나 웹 서비스를 위해 사용한 경우는 많지 않다.

목적에 따라 프로그래밍 언어는 다르다.

언어는 도구일 뿐이다.

# 3장 문법의 탄생

문법이란 프로그래밍 언어 설계자가 만든 ' 이렇게 쓰면 이런 의미로 해석된다 ' 라고 정한 규칙.

### 연산자 우선순위

사람이 편한 쪽으로 우선순위를 정한다.

## 3.2 스택머신과 FORTH

- FORTH
  - 1958년 경에 개발되어 문법이 거의 존재하지 않는 언어다.
  - 구문을 최대한 제한함으로 문제를 해결한다 는 것이 설계자의 주장이다.
  - 1과 2를 더한다를 코드로 표현하면
  ```jsx
  1 2 +
  ```
  - Stack 을 사용
  - 값을 스택에 담고 연산자가 나오면 2개를 스택에 꺼내어 계산.

### 현재도 살아있는 스택 머신

- Java, Python, Ruby 1.9 등은 스택 머신형의 VM을 사용.
- Java, Python, Ruby 등으로 프로그램을 짜면 내부적으로 FORTH 와 같은 프로그램으로 변환 되어 동작

FORTH 나 LISP 는 규칙이 적은 것을 중시.

FORTRAN 은 다가가기 쉬운 작성법을 중시. 이 설계 방침의 성공으로 많은 사랑을 받았다.

새로운 문법이 기존 문법과 마찰 될 때 이해하기 어려운 작성법이 생길 수 있다.

그만큼 마찰되지 않도록 설계하는 것이 중요하다.

# 4장 처리 흐름 제어

## 4.1 구조화 프로그래밍의 탄생

1960년대 후반 사람이 프로그램을 보다 편하게 쓰고 읽을 수 있도록 규칙을 만들자는 흐름을 타고

구조화 프로그래밍이 태어났다.

if 문이나 while 문 등의 규칙(구문)을 도입하여 코드 구조를 쉽게 만들자는 생각이었다.

## 4.2 if가 탄생하기 전

### if는 왜 있는 걸까?

조건을 만족하면 점프하기 위해 있고 점프라는 명령은 꽤 초기부터 존재했다.

### if-else 는 왜 있는 걸까?

if-else 없이도 프로그램 짜기는 가능하다 goto문을 이용한다던지

그래도 if-else를 쓰는 이유는 `간단하고 읽기 쉬운 형태로 쓰기 위해서다.`

## 4.3 while, 반복되는 if를 읽기 쉽게 표현

while문을 굳이 쓰지 않아도 프로그래밍으로 표기 가능하다.

while문 자체는 전혀 새로운 것은 아니다. 단지 좀 더 `읽기 쉽게, 쓰기 쉽게` 표현하기 위한 것이다.

## 4.4 for, 수치를 증가시키는 while을 읽기 쉽게 표현

for 문을 쓰면 조건을 쉽게 파악하기 쉽고 의도를 파악하기 쉽기 때문에 확실한 조건이 있다면 좀 더

보기 좋게 표현 할 수 있다.

```
while은 조건식을 반복.

for문은 횟수로 반복.

foreach 구문은 처리 대상으로 반복.
```

# 5장

## 5.1 함수의 역할

함수가 필요한 이유는 무엇인가?

함수가 없어도 프로그램은 구현 가능하다. 그렇지만 함수를 사용함으로써 우리에게 편함을 제공 해 준다.

### 이해(조직을 예로)

소스 코드 행수가 많아지면 전체를 파악하기 힘들지만 그룹으로 묵어서 관리하면 좀 더 쉽게 파악할 수 있다.

### 재사용(부품을 예로)

필요한 기능을 그룹으로 묵어 제공한다면 우린 그 부분을 쉽게 재사용 가능하다.

### 프로그램 재사용의 특징

길게 늘려있는 명령들을 자주 사용되는 단위로 잘라내어 정리함으로써 프로그램을 보다 쉽게 이해할 수 있다.

## 5.2 돌아가는 명령

goto 문으로 못하는것은 `원래 위치로 돌아가는 것`이다.

원래 위치로 돌아가 라는 명령이 가능하면 코드를 재사용할 수 있게 된다.

### 함수의 탄생

명령을 한곳에 모아두고 재사용하고 싶다라는 생각은 1949년 EDSAC에도 사용 되었었다.

프로그램 명령과 데이터는 컴퓨터 메모리에 동일한 형태로 기록되었다.

함수를 호출한 후 원래 위치로 돌아오는 것을 점프 명령의 목적지를 변경해서 구현했었다.

### 돌아갈 목적지를 기록하기 위한 전용 메모리

돌아갈 목적지를 기록해두는 전용 메모리를 만들어 돌아갈 목적지 메모리에 적어둔 번지로 점프하라는 명령을

준비해두는 방법.

이 방법의 문제점은 어떤 함수 X가 호출하고 있는 중에 함수 Y를 호출하면 돌아갈 목적지 메모리가 덮어씌워져서

X가 돌아갈 목적지를 잊게 된다.

### 스택

그래서 등장하는 것이 `스택`이다.

스택은 복수의 값을 저장해두는 데이터 구조이다.

스택의 머리가 어디인지를 기록하는 메모리 위치를 정하고 각각 저장위치에 데이터와 함수가 돌아갈 위치를

저장해 둔다.

### 5.3 재귀 호출

### 내포 구조 데이터의 효율적 처리

재귀 호출이 꼭 필요하진 않다. 그렇다면 왜 사용하는 것일까?

어떠한 처리를 재귀 호출을 사용해 매우 편하게 구현할 수 있기 때문이다.

### 내포구조를 다루는 방법

수많은 내포구조, 예를 들어 3중, 4중, 5중 내포가 되면 for문을 몇 개의 내포 관계로 구성한다고 해도

해결할 수 없다.

그래서 존재하는 것이 `재귀 호출`이다.

# 6장 에러 처리

## 6.1 프로그램도 실패를 한다.

예상을 하건 못하건 프로그램은 실패 할 수 있다. 그런 실패를 알아차리기 쉽지 않다

잘못 파악해서 다른 실수를 할 수도 있는 법이다. 대참사가 일어나기 전에 발견 할 수 있도록 가스 누출 검지기 같은

실패를 알리는 구조가 필요하다.

## 6.2 실패를 어떻게 전달할까?

예를 들어 shippai 라는 함수를 실행했다고 생각해 보자.

이 함수는 성공 or 실패 할 수 있다. 어떻게 그것을 처리하도록 만들면 될 것인가?

크게 2가지가 있다.

1. shippai 함수가 반환값으로 실패를 전달하고 호출하는 쪽에서 그 값을 체크해서 에러 처리.
2. shippai 함수를 호출하기 전에 에러 처리 코드를 등록하고, 실패 시 에러 처리 코드로 점프하는 방법.

### 반환값으로 실패를 전달한다.

전역변수에 함수 호출후 에러 처리를 저장할 수 있게 하든가 별도의 변수를 만들어 호출처에 제공 하든가 하는

방법으로 `실패했을 때 여기에 써놓을게, 나중에 확인해` 라는 구조이다.

이 방법의 문제점은 2가지가 있다.

1. 실패를 놓친다.
   - 프로그래머가 반환값 확인을 잊는다.(사람을 믿기 힘들다)
2. 에러 처리 때문에 코드를 해석하기 어렵다.
   - 모든 부분을 제대로 체크하기위해 모든 조건을 다 체크하면 사람이 코드를 읽기 어려워 진다.

### 실패하면 점프한다.

에러처리 부분을 하나의 그룹으로 묶어 처리한다. 로직을 구현하다 에러를 만날시 에러처리 부분으로 점프.

예전 프로그래밍 언어에서는 미리 실패했을 때 처리를 등록해둔 후 실패할 것 같은 코드를 쓰는 형식이다.

하지만 Java 등의 구문에서는 실패할 것 같은 코드를 미리 try{...} 로 묶어둔 후 처리한다.

1975년에 John Goodenough가 제안한 좋은 예외 처리 방법.

1. 명령이 어떤 예외를 던질 가능성이 있는지 명시적으로 선언.
2. 자발적으로 실패할 것 같은 처리를 묶는 것.( 현대 언어가 채용하는 방식)

### CLU에 도입

이전부터 코드를 begin .......end 로 묶어서 블록이라는 기능이 있었다. 여기에 except를 합쳐러 에러처리를 구현.

```
begin
	% 실패할 것 같은 처리
	% 실패할 것 같은 처리
end except when 실패 종류:
	% 실패했을 때 처리
	% 실패했을 때 처리
end
```

### C++에 도입

```cpp
try {
	/* 실패할 것 같은 코드 */
	/* 실패할 것 같은 코드 */
} catch {
	/* 에러 처리 명령 */
	/* 에러 처리 명령 */
}
```

예외 발생시키기 위한 명령으로 throw 용어가 만들어졌다.

### Windows NT 3.1에 도입

```c
__try{

	__try{
		/* 실패할 것 같은 코드 */
		/* 실패할 것 같은 코드 */
	}__finally{
		/* 실패해도 성공해도 실행하고 싶은 코드 */
	}
}__except(....){
	/* 에러 처리 코드 */
}
```

## 6.4 출구는 하나다.

왜 finally를 도입한 것일까?

구조화 예외 처리를 채용함으로 코드의 신뢰성을 높일 수 있다.

### 짝이 되는 처리를 반드시 실행한다.

- 메모리를 확보 후 나중에 개방.
- 파일을 열었다가 닫는 처리.
- 락을 걸었다 푸는 처리.

짝이 되는 처리를 한 쪽을 실행했다면, 다른 한쪽도 반드시 실행하는게 좋다.

짝이 되는 처리를 관리하지 않으면 파악하기 쉽지 않고 어디서 예외를 던지는 지 알 수 없다.

이 문제를 해결하는 방법은 3가지가 있다.

1. finally를 사용해서 해결

   ```c
   try{
   /* 실패할 것 같은 코드 */
   }catch{
   /* 에러 처리 코드 */
   }finally{
   /* 반드시 실행되는 코드 */
   }
   ```

2. Finally가 없는 C++에서의 해결

   - 클래스의 생성자에서 열어서 소멸자에서 닫는다. 함수를 벗어날 때 자동적으로 소멸자가
     호출되는 것을 이용한 기술.

3. D언어의 scope(exit)를 사용한 해결

## 6.5 어떤 경우에 예외를 던질까?

### 함수 호출 시 인수가 부족한 경우

파이썬과 루비는 인수가 부족하면 예외를 던진다.

자바스크립트에서는 undefined를 사용해서 처리한다.

### 배열 범위 밖에 있는 것을 취득하려고 했을 때

파이썬은 예외를 던진다.

루비는 null을 반환.

자바스크립트는 undefined를 반환.

예외적 상황이란 무엇인지에 대한 정답은 없다.

### 틀리면 바로 예외를 던진다.

예외를 던지는게 좋다. 이점은 실패를 놓치지 않는 것이다.

## 6.6 예외의 전파

어떤 함수에서 또다른 함수를 호출하고 그 함수에서 또 다른 함수를 호출했을 시 모든 함수를 보지 않고선 파악

하기 힘들다. 무슨 에러인지 확인하기 힘들다.

### Java의 검사 예외

어떤 예외를 던질지를 명시적으로 선언.

throw에서 던질 수 있는 것, 즉 예외를 좀 더 세분화하고 있다.

- 예외 처리를 하지 않아도 되는 문제.
- 예외 처리를 해도 좋은 실행 시 예외.
- 예외 처리를 해도 좋은 기타 예외.

### 검사 예외가 잘 사용되지 않는 이유

귀찮기 때문이다. throw나 try/catch에 기술하는 예외의 개수가 너무 방대해지거나 던질 예외를 하나 추가하면

그 메소드를 호출하고 있는 모든 메소드를 수정해야만 한다. 많은 에러처리로 인해 다른 부수적 단점이 생겨난다.

# 7장 이름과 스코프

## 7.1 왜 이름이 필요할까?

그 전에는 번호(메모리 번지)를 사용하였다. 하지만 사람이 이름이 붙혀 부르는 게 편한 것 처럼 부르기 쉽게 하기

위해 사용 되었다.

### 어떻게 이름을 붙일까?

컴퓨터가 이름과 물건을 대응 시키는 표를 가지고 있으면 가능하다.

```
{ 한국어 사전 => 36번째 책, 영어 사전 => 37번째 책, 중국어 사전 => 38번째 책 }
```

### 이름충돌

초기 프로그래밍 언어에서는 전역에 쓰이는 대응표를 공유하고 있었다. 전역으로 쓰일시에 문제는 존재한다.

```perl
for($i = 0; $i < 10; $i++) {
	&shori();
	print " 처리", $i, "종료 \n";
}

sub shori{
	$i = 0;
}
```

다음과 같이 쓰일시 shori 함수에서 \$i 값을 0으로 변경해 주기 때문에 무한 반복하게 된다.

### 충돌 피하기

위와 같이 전역으로 쓰일시엔 충돌나는 문제가 발생한다.

이를 방지하기 위해서 어떻게 하면 좋을까?

- 긴 변수명을 사용한다.
  - 단순히 유니크하게 변수를 쓸 수 있게 길게 쓰거나 자기만의 고유 이름을 정하여 사용한다.
- 스코프를 이용한다.
  - 위와 같은 사항은 사람이 변수명을 관리해야 하기 때문에 유용하진 못하다.

## 7.2 스코프의 진화

스코프란 이름의 유효 범위다.

### 동적 스코프

- 어떤 방식으로 동작하는가
  - 함수 입구에 원래의 값을 기록하고 출구에서 원래의 값으로 되돌리기.
  ```perl
  sub shori{
  		$old_i = $i;
  		$i = 0; #여러 가지 처리
  		$i = $old_i;
  }
  ```
  - 이 방법으로 할땐 원래의 값을 반드시 리턴 해야 한다.
  - 사람은 실수하기 마련이다. 1991년에 출시된 perl4 부터는 변수를 local 로 선언하면 언어 처리계가
    `원래의 값을 다른 곳에 피신시켜두고 나중에 되돌린다.` 를 알아서 해준다.
    이런 스코프를 `동적 스코프`라고 한다.
  ```perl
  sub shori{
  		local $i;
  		$i = 0;
  }
  ```
- 문제점

  - 변수를 변경한 후 다른 함수를 호출한 경우 호출된 함수에 영향을 미친다.

  ```perl
  $x = "global";

  sub yobu{
  		local $x = "yobu";
  		&yobareru();
  }

  sub yobareru{
  	print "$x \n"; # yobu 라고 표시된다.
  }

  &yobu();
  ```

  - 동적스코프를 사용하면서 전역변수에는 영향을 주지 않게 되었지만 함수 yobu 안에서의 변경은
    함수내에서 호출한 yobareru 에 영향을 끼치게 되었다.

### 정적 스코프

- 하나의 전역공간을 쓰는게 아니라 함수가 호출될 때마다 하나의 공간을 가지게 하는 것이다.
- 동적 스코프는 대응표를 코드 전처에서 읽을 수 있다.
  - 동적스코프로 지역 변수 x를 만든다는 것은 다음 3가지 처리를 의미한다.
    - 함수 yobu에 들어갔을 때 새로운 대응표를 준비.
    - 함수 yobu 내에서 변수 x에 대입하는 것은 대응표에 기록.
    - 함수 yobu를 벗어날 때 그 대응표를 제거.
  - 동적스코프에서 만들어진 대응표는 전역에서 읽고 쓸 수 있다.
- 정적 스코프는 함수별로 대응표를 나눈다.
  - 언어 처리계는 다음 3가지 처리를 한다.
    - 함수 yobu 에 들어갔을 때 함수 yobu 전용의 새로운 대응표를 준비.
    - 함수 yobu 내에서 변수 x에 대입하는 것은 대응표에 기록.
    - 함수 yobu를 빠져나갈 때 해당 대응표를 제거.
- 동적 스코프도 아직 부족한 점이 있고, 이를 해결 하기 위해 정적 스코프가 개발되었다.

## 7.3 정적 스코프는 완성체인가?

아직 몇가지 문제가 남아있다.

파이썬 2.0에서는 대응표(스코프)에 3가지 계층이 있다.

범위가 넓은 것부터 순서대로 빌트인, 전역, 지역 3가지다.

전체를 위한 대응표(빌트인)

파일 단위의 대응표(전역 대응표)

함수별 대응표(지역 대응표)

파이썬은 대입과 함께 변수를 만드는 언어다. 자바스크립트의 var에 해당하는 변수 선언은 없다.

함수 안에서 대입하면 지역변수가 된다.

2가지 문제점

- 내포된 것처럼 보이는 스코프가 실제로는 내포되어 있지 않다.
  - 파이썬은 함수안에서 새로운 함수를 정의할 수 있다.
  ```python
  x = 'global'
  def foo():
  		x = "foo"
  		def bar():
  				print x
  		bar()
  foo()
  ```
  - 자연스럽게는 foo가 출력된다고 하겠지만 사실 파이썬2.0까지는 global이 출력된다.
  - 사람이 보기에는 foo 안에 속하기 때문에 foo가 출력 될 것 같지만 실제로는 다른 대응표를 각각 가지고
    처리되게 되어 있었다.
  - 파이썬 2.1 에서는 foo가 출력되게끔 수정되었다.
- 외부 스코프에 재귀속되는 문제

  - 내포한 스코프의 외부 변수를 변경할 수 없다.
  - 해당 스코프에 이미 선언한 변수가 있다면 그 변수값을 변경하고 없으면 새로운 지역변수를 설정한다.

  ```python
  def foo():
  		x = "old"
  		def bar():
  				x = "new"
  				# 외부 x를 바꾸고 싶지만
  				# 새로운 지역 변수를 만들어버림
  		bar()
  		print(x)

  foo() # -> old (변경되지 않음)
  ```

- 파이썬에서의 해결 방법

  - 파이썬 3.0 에 채용된 방법은 함수 서두에서 변수를 `nonlocal` 이라고 선언하는 것이었다.

  ```python
  def foo():
  		x = "old"
  		def bar():
  				nonlocal x # 지역 변수가 아님을 선언
  				x = "new" # 외부 스코프를 변경
  		bar()
  		print(x)

  foo() # -> new (변경되어 있다.)
  ```

# 8장 형

## 8.1 형이란?

사람이 데이터에 붙인 `추가 데이터` 이다.

컴퓨터가 0과1로 여러 값들을 표현하고 비트열을 어떤 값으로 해석하는지의 방법은 사람이 마음대로 정한

약속에 불과하다. 같은 비트열이라도 그것을 어떤 종류의 값으로 해석할지에 따라 틀린 값이 된다.

이를 피하기 위해 `어떤 종류의 값인가?` 라는 정보를 추구한 것이 형의 시작이다.

## 8.2 수치를 On과 Off로 표현하는 방법

1. 필요한 숫자만큼 on과 off로 나누어 표현
2. 자릿수를 정하여 표현.(1의자리 10의 자리 100의 자리)
3. 세그먼트 디스플레이(전자 시계같은)
4. 주판

## 8.3 한 자리에 필요한 램프는 몇 개일까?

하나의 램프로 2가지 부호 표현 가능

두개의 램프로는 2 \* 2 로 네가지 부호 표현 가능

3개로는 2*2*2 로 8가지 이므로 0 ~ 9 까지 10가지 부호를 표현할 수 없다.

램프가 4개면 16가지 표현 가능 하기에 10가지 부호를 표현 가능

UNIVAC I 등 초기 컴퓨터는 4개의 ON/OFF 를 사용해서 수치 표현했고 이를 Excess-3(액세스-3) 이라고 한다.

이것을 사용하면 12개의 램프로 0 ~ 999까지 표현 가능

### 10진수에서 2진수로

램프 4개로 16가지 표현 가능한데 10가지만 사용하기엔 아쉽다.

1의 자리, 10의 자리, 100의 자리 로 자릿수를 맞추는 대신 1의 자리, 2의 자리, 4의 자리 8의 자리로 맞추기(2진수)

2진수로 맞추면 0 ~ 1023 까지 표현 가능

### 8진수와 16진수

1000은 10진수로 표현법, 2진수로 바꾸면 1111101000 이다. 사람이 읽기 어렵다.

2진수 문자 몇 개를 모아서 한 개의 문자로 표현함으로 사람이 읽기 쉽게 표현(8진수, 16진수)

### 8진수

2진수 1111101000 는 읽기 어려우니 8개로 표현 가능하게 001 111 101 000 으로 나눈다.

한개의 문자로 바꾸면 1750이 된다.

### 16진수

마찬가지로 16진수는 네가지로 나누면 0011 1110 1000 이다.

2진수 네문자를 한개의 문자로 바꾸면 '3e8' 이다.

일반적으로 8진수 수치의 앞자리에는 0 이나 0o를 붙이고, 16진수 수치에는 0x를 붙이는 경우가 많다.

## 8.4 실수는 어떻게 표현할까?

### 고정 소수점 - 소수점을 어디에 붙일지 정한다.

1. 소수점을 어디에 붙일지 정한다.
   정수를 소수점 4자리 이동시켜 소수점 이하 4자리를 소수부라고 정하면
   1은 0.0001 이 되고 100은 0.0100 즉 0.01이 된다.
   이 방법의 단점은 0.0001보다 작은 값을 표현 하지 못함.
   새로운 규칙으로 5자리 이하 소수점 이동하면 되지만 그 것을 사람이 기억하는건 어렵다.

### 부동 소수점 - 어디부터 소수부인지의 정보 자체를 값에 포함시킨다.

어디부터 소수부인가를 사람이 판단하기 힘드니 값에 포함.

- 어떤 방식인가?
  16개의 램프로 소수를 표현한다면
  10개로 0 ~ 1023 까지 표현
  나머지 6개로 0 ~ 63 까지 표현 가능하기에 이것을 소수점 위치로 표현.
  큰 수 표현에도 사용가능
  하나의 자리까지 제대로 표현하기 위해선 16개 램프를 사용해도 6만개 정도만 표현 가능.
  소수점 위치를 표현하고 있는 0 ~ 63에서 예를 들어 33을 빼서 -33 ~ 30 범위를 표현하자고 하고
  -1 이 `소수점을 왼쪽으로 하나 이동한다 = 10으로 나눈다` 였던 것과는 반대로
  +1은 `소수점을 오른쪽으로 하나 움직인다 = 10배한다` 는 의미라고 하자.
  이 방법으로 1023 이후에 0이 30개 계속되는 큰 숫자를 표현 가능.
  이 것이 현재 일반적으로 사용되고 있는 부동 소수점이 가진 기본적인 아이디어(IEEE 754)

### IEEE 754가 정의하고 있는 부동 소수점 구조

지수부가 소수점 위치

가수부가 유효 숫자의 소수점 이하 부분

죄측 끝 램프는 수의 부호를 표현( 0이면 양수, 1이면 음수)

부호를 표현하는 램프를 제외하고 옆으 8개의 램프는 지수부.

지수부가 표현가능한 정수는 0 ~ 255이고 127을 빼면 -127 ~ 128 범위를 표현 가능

-127과 128에 특별한 의미(제로, 무한대)를 할당 하고 나머지 -126 ~ 127에 소수점 위치 표현

-126은 소수점을 왼쪽으로 126자리 이동하고 127은 오른쪽으로 127 이동을 의미.

나머지 23개가 가수부이다. 가수부는 소수점 이하 부분을 표현.

가수부 제일 왼쪽 램프는 1/2( 2진수의 0.1), 다음 램프는 1/4( 2진수의 0.01)을 표현

### 문제점

대부분 언어에서 실수는 부동 소수점으로 표현.

이 방법으로 3 / 10 의 결과를 표현할 때 10진수로는 0.3을 사용 가능

2진수의 경우 무한 소수가 된다. 이로 인해 0.3을 10회 더한 후 소수자리를 버려버리면 2가 돼버리는 현상이 발생.

```jsx
// 0.3 을 10회 더해도 3이 되지 않는다.
0.3 + 0.3 + 0.3 + 0.3 + 0.3 + 0.3 + 0.3 + 0.3 + 0.3 + 0.3 // 2.99999...6

// 소수점 자리를 버리면 2가 돼버린다.
Math.floor(0.3 + 0.3 + 0.3 + 0.3 + 0.3 + 0.3 + 0.3 + 0.3 + 0.3 + 0.3) // 2
```

돈을 다루는 분야에서는 용납되지 않는 현상이다.

고정 소수점수나 Excess-3과 같은 10진수 계산법이 사용된다.

## 8.5 형은 무엇을 위해 존재할까?

사람에게 보이는 정수 7과 부동소수점 0.7은 비슷해보이지만 컴퓨터는 전혀 다른 수로 보인다.

램프에 불로 표현 하던 비트 패턴을 보더라도 완전히 다르게 구분이 된다.

그래서 이 값이 어떤 종류인지 정보가 별도로 필요하다. `그것이 형이다`

### 형이 없을 때 발생하는 문제

부동 소수점 3.0 + 7.0 = 10.0( 부동소수점을 덧셈하라는 명령을 사용)

값이 들어 있는 메모리에 부동소수점이라는 것을 잊어버리고 `정수를 덧셈하라`는 명령을 사용하면 어떻게 될까?

3.0과 7.0이 비트 패턴을 정수로 읽어 들이면 매우 큰 값이 된다. 부동소수점에서 지수부로 나오던 값이 정수로

읽으면 그 위치가 몇승으로 처리되기 때문이다.

### 초기 FORTRAN의 형

메모리에 기록된 값이 정수인지 부동 소수점인지 기억하기는 매우 피곤한 일

편하게 할 한가지 방법은 변수명에 안에 든 것이 무엇인지 표현하기 위한 규칙을 만드는 것

FORTRAN에서는 변수명 선두가 1 ~ N 이면 정수, 그 이외이면 부동 소수점 이라는 규칙 사용.

### 언어 처리계에 변수 종류를 알린다

언어 처리계가 `이 변수는 정수다` 라고 컴퓨터에게 알려주는 것으로 이것이 변수형 선언이 탄생한 이유다.

C언어에서는 int x; 라고 선언하면 x라는 이름이 가리키고 있는 메모리 영역은 정수로 해석.

float y; 라고 선언하면 y가 가리키고 있는 메모리는 부동 소수점으로 해석.

이렇게 형 정보를 줌으로써 어떤것으로 인식할지 판단하게 한다.

### 암묵의 형 습격

정수 덧셈과 부동 소수점 덧셈은 전혀 다른 차원의 처리다. 적절히 나눠 처리해야 한다.

1. 정수끼리, 부동 소수점끼리의 연산
2. 한 쪽이 정수고 다른 한 쪽이 부동 소수점인 연산
   초기 FORTRAN에서는 이 경우는 에러 처리를 했다.
   그래서 프로그래머가 명시적으로 변환을 위한 함수를 사용.
   C언어는 정수를 부동 소수점으로 암묵적 변환을 시킴.
   x + 1024가 있고 x가 부동 소수점이면 1024를 부동 소수점으로 변환 후 덧셈.
   편해 보일 수 있는 방법이다.
3. 문제점
   x / 2 를 할때
   x가 정수이면 나눗셈을 한 후 소수점 이하를 버린다.
   x가 1이면 계산 결과는 0
   x가 부동 소수점이라면
   나눗셈을 하고 부동 소수점으로 표현할 수 있는 수치로 다듬는다.
   x가 부동 소수점 1이라면 결과는 0.5
   x가 어떤 형인지 기억하지 않으면 소수점 이하를 버리는지 아닌지를 알 수 없다.
4. 코드 작성법으로 구별하는 언어
   사람이 설계에 따라 다르다.

## 8.6 형의 다양한 전개

형의 다양한 응용법.

### 사용자 정의형과 객체 지향

언어가 가지는 기본형을 조합해서 새로운 형을 만다는 기능의 발명.

대표적인 예는 C언어의 구조체(사용자 정의형)

```c
// 정수형과 문자열 형을 조합해서 새로운 person 형을 만듬.
struct person {
	int age;
char *name
};
```

장수 등 데이터 뿐만 아니라 함수 등 데이터를 처리하는 기능도 형으로 정리.

`사용자가 정의할 수 있는 형` 이야 말로 프로그램을 구축하기 위한 기본적 요소(클래스라 이름을 붙힘)

이것이 제2의 객체 지향의 발명

### 사양으로서 형

1. 공개와 비공개를 나누다
   `형은 사양이다` 라는 개념의 등장.
   구조체나 클래스를 구성하는 형을 전부 공개하지 않고 최소한만을 공개
   형이 맞는지 아닌지는 컴파일러가 체크.
   외부와 작업하는 부분만을 형으로 공개, 상세 구현 방법은 숨긴다라는 발상(모듈이나 추상 데이터형에 사용)
   public이나 private
2. 인터페이스로 발전
   `형은 사양이다` 라는 개념에서 더욱 진화.
   구체적인 구현 방법을 가지고 있지 않은 형(인터페이스)이 탄생.
   함수가 예외를 던질지 말지 의 정보도 형에 포함하는 언어가 등장(Java의 검사 예외등등)
   다음 인터페이스는 `인수를 가지지 않고, 값은 반환하지 않는 run 이라는 이름의 메소드를 가지고 있다` 라는
   사양을 표현

```java
package java.lang;
public interface runnable {
		public abstract void run();
}
```

어디에 사양은 사용될까?
인수를 가지지 않고 값은 반환하지 않는 run 이라는 이름의 메소드를 가지고 있다 라는 사양만 만족하다면
어떤 구현 방법을 사용하든 상관없다라는 사양을 표현

3. 형으로 모든 사양을 표현하는 세상이 올까?

형으로 모든 사양을 표현하는 것은 성공하지 못하고 있다.

가능하다면

`형이 일치하면 내부 구현에 관해선 신경 쓰지 않아도 된다.`

`사양과 형이 일치하지 않으면 검파일러가 검출해준다.`

`컴파일을 통과하면 버그는 없다`

라는 이상적인 현실이 가능.

형으로 표현되지 않은 정보는

`이 데이터를 입력하면 어느 정도 시간이 걸리지?`

`처리 과정에 어느 정도의 메모리가 필요할까?`

`스레드 안에서 이 처리를 사용해도 되는 걸까?`

등은 지금도 사람이 자료나 소스 코드를 통해 판단해야 하는 것이 현실.

### 총칭형, 제네릭스, 템플릿

다양한 형을 조합해서 만든 복잡한 형이 사용되면서 일부만 바꾸고 싶은데 전부 다시 정의해야 하는 것의 문제 발생

재사용의 필요성

그래서 `구성 요소의 형을 일부만 바꾸는 형`( 총칭형의 탄생)

형이 인수를 가지고 형을 만드는 함수의 탄생

C++의 템플릿 Java의 제네릭 Haskell의 형 생성자

C++의 경우

```cpp
#include <iostream>

template<typename T>
struct person {
	int age;
	char *name;
	T something; // 1
};

int main() {
	person<int> x; // 2
	x.something = 1; // 3
	person<const char*> y; // 4
	y.something = 'hoge'; // 5

	std::cout << x.something << std::end1 // -> 1
	std::cout << y.something << std::end1; // -> hoge
}
```

something의 형은 지금 정하지 않는다.

template<typename T>.......; 이라고 정의해서 `T는 나중에 구체적인 형을 넣기 위한 형 인수 라고 선언`
main에서 int형 char형으로 나중에 구현.

Java의 경우

```java
public class GenericsTest {
		public static void main(String[] args) {
				Person<Integer> x = new Person<Integer>(); // 1
				x.something = 1;
				Person<String> y = new Person<String>();
				y.something = 'hoge';
				System.out.println(x.something); // 1
				System.out.println(y.something); // hoge
		}
}

class Person<T>{
		public Integer age;
		public String name;
		public T something;
}
```

Java도 비슷하다.

이것을 총칭형을 가지고 있지 않은 언어로 표현한다면 형 인수가 사용되고 있는 부분을 모두 사람이 바꿔서

각각의 형을 위한 코드를 만들어야 한다.

### 동적 형결정

지금까지 설명의 형 구조는 `변수명`, `값이 저장된 메모리 위치`, `해당 메모리의 내용은 어떤 종류의 값인가` 를

언어 처리계가 한 세트로 가지고 있었다.

이런 종류 정보를 값과 함께 세트로 가지고 있는 것을 `동적 형결정` 이라 한다.

현재는 대부분의 스크립트 언어가 채용하고 있다.

예를 들어 동적 형결정 언어 중 하나인 파이썬에서는 변수형을 선언할 필요가 없고 같은 변수에 정수와 부동 소수점

모두 넣을 수 있다.

```python
x = 1234
x = 3.1415
```

어떻게 표현하고 있을까

동적 형결정 언어에서 형 선언이 필요 없는 것은 메모리 상에서 동일한 형으로 취급되도록 설계되어 있기 때문이다.

예를 들어 파이썬에서 값은 정수든 부동 소수점이든 문자열이든 모두 pyObject 형으로 취급되도록

머리 부분이 모두 같은 형태로 되어 있다. 그리고 pyObject 형의 구조 안에는 값의 종류 정보를 저장할 수 있는

공간이 마련되어 있다.(책 그림 8.13 참조 page 133)

파이썬 변수 x는 C 언어로 표현하면 PyObject\* x 이다.

그래서 값을 꺼내려면 먼저 메모리 상의 비트열을 pyObject로 읽어 들어야 한다.

그곳에는 값이 정수인지 부동 소수점인지 문자열인지의 종류 정보가 들어있다.

장점과 단점

종래의 정적 형결정 언어에서는 할 수 없었던 유연한 처리 가능.

실행 전까지 형을 정해두지 않아도 되며, 실행 시에 형이 바뀌는 것도 가능(이것이 단점이기도 하다)

정적 형결정 언어는 컴파일 시에 형이 정해지고, 컴파일 시에 형의 정합성이 체크된다.

이런 형 체크 덕분에 일부 버그는 실행 전에 찾아낼 수 있다.

하지만 동적 형결정 언어에서는 그것이 불가능

### 형 추론

`컴파일 시에 형 체크는 하지만 귀찮은 형 선언은 하고 싶지 않다.` 이를 위해 컴퓨터가 형을 추론하게 하는

접근이 있다.

원래는 ML계 언어가 잘하는 분야지만 최근에는 Java VM 상에서 동작하는 언어인 Scala 등 형 추론을 장점으로 부각시키는 언어가 늘고 있다.

## 추가 정보

### 바이어스표현법 - 지수부가 8비트인 부동 소수점을 표현할 때

0000 0000 : -127
0000 0001: -126
...

0111 1111: 0

...

1111 1111: 128

---

예) 19.25를 127 바이어스법으로 바꾸면

19 를 이진수로 변경하면 10011

0.25는 0.01 이다. 그래서 10011.01 이다.

여기에 정규화를 하면 1.001101 에 2의 4승이 된다

= 10011.01(2진수)

= 1.001101 \* 2의 4승

4 = 100(2진수)

여기서 비트부를 바이어스 법으로 바꾸면

100 + 0111 1111 = 1000 0011

따라서 지수부는 1000 0011

이 방식에 따라서 263.3을 기록하면

- 부호 비트(1 bit) : 0 (양수)
- 지수 비트(8 bit) : 10000111 (127 + 8 = 135)
- 가수 비트(23 bit) : 00000111010011001100110이렇게 표현할 수 있습니다.

하지만! 여기서도 0.010011001100110은 정확히 0.3을 나타낼 수는 없습니다. 10진수로 나타내 보면 0.29998779296875을 나타냅니다.

### **부동 소수점 오류 예**

0.1을 100번 더하면 10이 나와야 되는데...0.1을 정확히 표현할 수 없기 때문에 발생하는 오류입니다.

### **2의 보수**

▶ **1의 보수** : 각 자릿수의 값이 모두 1인 수에서 주어진 2진수를 빼면 1의 보수를 얻을 수 있습니다.

예시 ) 2진수 1010의 1의 보수는 0101입니다.

▶ **2의 보수** : 1의 보수에 1을 더한 값과 같습니다.

예시 ) 2진수 1010에 대한 2의 보수를 구하려면 2진수 1010에 대한 1의 보수 0101을 구한 다음 1을 더해 0110을 얻습니다.

```
- 1의 보수 뺄셈 : 1의 보수를 이용한 뺄셈은 빼는 수의 1의 보수를 구한 다음 더합니다.
	덧셈한 결과가 최상위 비트에서 자리올림이 생겼다면 최하위 비트에 1을 더하고,
	자리올림이 생기지 않았다면 연산 결과에 대해 1의 보수를 구한 후 - 부호를 붙입니다.

  예시 ) 111(2) - 110(2) = 111(2) + 001(2) = 1000(2)에서 최상위 비트를 지우고 1을 더하므로
				답은 1(2)입니다.

  예시 ) 100(2) - 110(2) = 100(2) + 001(2) = 101(2)에서 다시 1의 보수를 취하므로
				답은 10(2)입니다.

 - 2의 보수 뺼셈 : 2의 보수를 이용한 뺄셈은 빼는 수의 2의 보수를 구한 다음 더합니다.
		덧셈한 결과가 최상위 비트에서 자리 올림이 생겼다면 자리올림을 제외한 나머지 부분이 연산 결과이고,
		자리 올림이 생기지 않았다면 연산 결과의 2의 보수를 구한 후 - 부호를 붙입니다.

  예시 ) 111(2) - 110(2) = 111(2) + 010(2) = 1001(2)에서 최상위 비트를 지우므로
				답은 1(2)입니다.

  예시 ) 100(2) - 110(2) = 100(2) + 010(2) = 110(2)에서 답은 010(2)입니다.

```

출처: [https://ndb796.tistory.com/4](https://ndb796.tistory.com/4)
